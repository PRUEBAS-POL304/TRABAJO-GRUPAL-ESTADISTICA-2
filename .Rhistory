library(equatiomatic) # Instalar remotamente:
#install.packages("equatiomatic")
#remotes::install_github("datalorax/equatiomatic")
library(modelsummary)
library(factoextra)
library(cluster)
library(lmtest)
library(nortest)
library(BBmisc)
library(rio)
dataUNIFICADA = "https://github.com/luccemhu/TRABAJO-GRUPAL-ESTADISTICA-2/raw/main/ENTREGA2/df_final.csv"
datavar = import(dataUNIFICADA)
table = datavar[, c(1, 3)]
datatable(table, filter = "top")
modelo1 = lm(desempleo ~ inverex + PBI, data = datavar)
summary(modelo1)
modelo2 = lm(desempleo ~ inverex + PBI + gastoseduc + inftransito + obeadult,
data = datavar)
summary(modelo2)
equatiomatic::extract_eq(modelo2, use_coefs = TRUE)
model = list('desempleojuv' = datavar)
modelsummary(modelo2,
title = "OLS",
stars = TRUE,
output = "kableExtra")
plot(modelo2, 1)
plot(modelo2, 3)
bptest(modelo2)
plot(modelo2, 2)
shapiro.test(modelo2$residuals)
plot(modelo2, 5)
checkModelo2=as.data.frame(influence.measures(modelo2)$is.inf)
head(checkModelo2)
checkModelo2[checkModelo2$cook.d & checkModelo2$hat, ]
boxplot(normalize(datavar[, -1], method = 'range', range = c(0, 1)))
boxplot(normalize(datavar[, -1], method = 'standardize'))
datavar[, -1] = normalize(datavar[, -1], method = 'standardize')
cor(datavar[, -1])
datavar$PBI = -1 * datavar$PBI
#Veamos correlaciones entre estas variables tipificadas:
cor(datavar[, -1])
dataClus = datavar[, -1]
#row.names(dataClus) = datavar$pais
library(cluster)
g.dist = daisy(dataClus, metric = "gower")
# PAM:
library(factoextra)
fviz_nbclust(dataClus,
pam,
diss = g.dist,
method = "gap_stat",
k.max = 10,
verbose = F)
fviz_nbclust(dataClus,
hcut,
diss = g.dist,
method = "gap_stat",
k.max = 10,
verbose = F,
hc_func = "agnes")
#**DIANA:**
fviz_nbclust(dataClus, hcut, diss = g.dist, method = "gap_stat", k.max = 10, verbose = F, hc_func = "diana")
#PAM
set.seed(123)
grupos = 4
res.pam = pam(g.dist, k = grupos, cluster.only = F)
dataClus$pam = res.pam$cluster
#Agnes
res.agnes <- hcut(g.dist,
k = grupos,
hc_func = 'agnes',
hc_method = "ward.D")
dataClus$agnes = res.agnes$cluster
#Diana
res.diana <- hcut(g.dist, k = grupos, hc_func = 'diana')
dataClus$diana = res.diana$cluster
#PAM:
fviz_silhouette(res.pam)
fviz_silhouette(res.agnes)
#DIANA:
fviz_silhouette(res.diana)
library(magrittr)
silPAM = data.frame(res.pam$silinfo$widths)
silPAM$country = row.names(silPAM)
poorPAM = silPAM[silPAM$sil_width < 0, 'country'] %>% sort()
silAGNES = data.frame(res.agnes$silinfo$widths)
silAGNES$country = row.names(silAGNES)
poorAGNES = silAGNES[silAGNES$sil_width < 0, 'country'] %>% sort()
silDIANA = data.frame(res.diana$silinfo$widths)
silDIANA$country = row.names(silDIANA)
poorDIANA = silDIANA[silDIANA$sil_width < 0, 'country'] %>% sort()
poorPAM
poorAGNES
poorDIANA
aggregate(. ~ agnes, data = dataClus, mean)
original = aggregate(. ~ agnes, data = dataClus, mean)
original[order(original$inverex), ]
original[order(original$PBI), ]
original[order(original$desempleo), ]
original[order(original$inftransito), ]
original[order(original$obeadult), ]
original[order(original$gastoseduc), ]
#Guardamos las columnas de PAM, AGNES Y DIANA en la data integrada, y eliminemosla de dataClus.
datavar$pamVARpoor = datavar$pais %in% poorPAM
datavar$pamVAR = as.ordered(dataClus$pam)
dataClus$pam = NULL
datavar$agnesVARpoor = datavar$pais %in% poorAGNES
datavar$agnesVAR = as.ordered(dataClus$agnes)
dataClus$agnes = NULL
datavar$dianaVARpoor = datavar$pais %in% poorDIANA
datavar$dianaVAR = as.ordered(dataClus$diana)
dataClus$diana = NULL
proyeccion = cmdscale(g.dist, k = 2, add = T)
datavar$dim1 <- proyeccion$points[, 1]
datavar$dim2 <- proyeccion$points[, 2]
library(ggrepel)
base = ggplot(datavar, aes(x = dim1,
y = dim2,
label = row.names(dataClus)
)
)
base + geom_text_repel(size = 3,
max.overlaps = 50,
min.segment.length = unit(0, 'lines')
)
# Gráfica de PAM
# Conglomerados PAM en Mapa Bidimensonal de países
# solo paises mal clusterizados
PAMlabels = ifelse(datavar$pamVARpoor, datavar$pais, '')
# base
base = ggplot(datavar, aes(x = dim1, y = dim2))  +
scale_color_brewer(type = 'qual', palette = 'Dark2') +
labs(subtitle = "Se destacan los países mal clusterizados")
pamPlot = base + geom_point(size = 3,
aes(color = pamVAR))  +
labs(title = "PAM")
# hacer notorios los paises mal clusterizados
pamPlot + geom_text_repel(
size = 4,
aes(label = PAMlabels),
max.overlaps = 50,
min.segment.length = unit(0, 'lines')
)
# solo paises mal clusterizados
AGNESlabels=ifelse(datavar$agnesVARpoor,datavar$pais,'')
agnesPlot=base + geom_point(size=3,
aes(color=as.factor(agnesVAR))) +
labs(title = "AGNES")
# hacer notorios los paises mal clusterizados
agnesPlot + geom_text_repel(size=4,
aes(label=AGNESlabels),
max.overlaps = 50,
min.segment.length = unit(0, 'lines')
)
# Gráfica de DIANA
# Conglomerados DIANA en Mapa Bidimensional de países:
# solo paises mal clusterizados
DIANAlabels = ifelse(datavar$dianaVARpoor, datavar$pais, '')
dianaPlot = base + geom_point(size = 3,
aes(color = dianaVAR)) +
labs(title = "DIANA")
# hacer notorios los paises mal clusterizados
dianaPlot + geom_text_repel(
size = 4,
aes(label = DIANAlabels),
max.overlaps = 50,
min.segment.length = unit(0, 'lines')
)
library(rgdal)
library(sp)
#debemos agregar el ISO para el mapa
ISO = "https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes/raw/master/all/all.csv"
dataISO = read.csv(ISO)
#Eliminando columnas innecesarias:
dataISO = dataISO[, -c(2, 4:11)]
newnames = c("pais", "ISO3_CODE")
names(dataISO) = newnames
dataISOvar = merge(datavar, dataISO, by = "pais")
## SUBDATA: VARIABLE INDEPENDIENTE, PAIS E ISO:
varindep = dataISOvar[, c(1, 4, 16)]
mapDIS = sf::read_sf("./SHAPEFILES/shapes_mundo.shp") # shapefile
mapDIS2 = merge(mapDIS,
varindep,
by.x = 'ISO3_CODE',
by.y = 'ISO3_CODE',
all.x = T) #siempre primero el shape
names(mapDIS)
### Mapa de variable dependiente
mapaleyendaL = ggplot(mapDIS2) + geom_sf() + theme_light()
mapaleyL = mapaleyendaL + geom_sf(data = mapDIS2,
aes(fill = desempleo),
color = "gray")
mapa = mapaleyL +
coord_sf() + theme_void() +
theme(
axis.title = element_blank(),
axis.text = element_blank(),
legend.position = "bottom"
) + labs(fill = " ") + theme(legend.text = element_text(size = 10)) +
labs(title = "Desempleo juvenil en el mundo") +
theme(plot.title = element_text(
color = "black",
size = 10,
face = "bold"
))
mapa
### Mapa de variable dependiente
mapaleyendaL = ggplot(mapDIS2) + geom_sf() + theme_light()
mapaleyL = mapaleyendaL + geom_sf(data = mapDIS2,
aes(fill = agnesVAR),
color = "gray")
mapa = mapaleyL +
coord_sf() + theme_void() +
theme(
axis.title = element_blank(),
axis.text = element_blank(),
legend.position = "bottom"
) + labs(fill = " ") + theme(legend.text = element_text(size = 10)) +
labs(title = "Desempleo juvenil en el mundo") +
theme(plot.title = element_text(
color = "black",
size = 10,
face = "bold"
))
mapa
View(mapDIS2)
View(datavar)
View(dataISOvar)
## SUBDATA: VARIABLE INDEPENDIENTE, PAIS E ISO:
varindep = dataISOvar[, c(1, 2, 16)]
View(varindep)
mapDIS = sf::read_sf("./SHAPEFILES/shapes_mundo.shp") # shapefile
mapDIS2 = merge(mapDIS,
varindep,
by.x = 'ISO3_CODE',
by.y = 'ISO3_CODE',
all.x = T) #siempre primero el shape
names(mapDIS)
### Mapa de variable dependiente
mapaleyendaL = ggplot(mapDIS2) + geom_sf() + theme_light()
mapaleyL = mapaleyendaL + geom_sf(data = mapDIS2,
aes(fill = desempleo),
color = "gray")
mapa = mapaleyL +
coord_sf() + theme_void() +
theme(
axis.title = element_blank(),
axis.text = element_blank(),
legend.position = "bottom"
) + labs(fill = " ") + theme(legend.text = element_text(size = 10)) +
labs(title = "Desempleo juvenil en el mundo") +
theme(plot.title = element_text(
color = "black",
size = 10,
face = "bold"
))
mapa
dataClus$pais = row.names(dataClus)
row.names(dataClus) = NULL
datavar = merge(datavar, dataClus, by = "pais")
datavar$agnesVAR = factor(datavar$agnesVAR)
mapDIS3=merge(mapDIS,dataISOvar,
by.x='ISO3_CODE',
by.y='ISO3_CODE',
all.x = T)
mapaleyendaL= ggplot(mapDIS3)+ geom_sf() + theme_light()
mapaleyL= mapaleyendaL + geom_sf(data=mapDIS3,
aes(fill=agnesVAR),color = "gray")
mapa3= mapaleyL +
coord_sf() +
scale_fill_manual(values=c("#29211F","#65A752","#1C6AA8","#D72E3E")) + theme_void() +
theme(axis.title = element_blank(), axis.text = element_blank(), legend.position = c(1.1,0.55)) + labs(fill=" ") + theme(legend.text = element_text(size = 13)) +
labs(title = "4 clusters",caption = "Fuente: Banco Mundial 2022. Elaboración propia.  @luccemhu") +
theme(
plot.title = element_text(color="black", size=15, face="bold"),
plot.caption = element_text(color = "black", size=10))
mapa3
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
f1 = formula( ~ MATH + WRTG) # Asimétricas, correlacionadas pero ninguna es V.D. o V.I.
# camino parametrico:
pearsonf1 = cor.test(f1, data = hsb)[c('estimate', 'p.value')]
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(rio)
organization = 'https://github.com/Estadistica-AnalisisPolitico'
repo = '/DataFiles-estadistica/raw/main/'
file = 'hsb_ok.xlsx'
hsb = import(paste0(organization, repo, file)) # importando 3 datas
#str(hsb)
# FORMATEAMOS:
categoricals = c("SEX", "RACE", "SES", "SCTYP", "HSP", "CAR")
hsb[, categoricals] = lapply(hsb[, categoricals], as.factor)
# nominales
hsb$SEX = factor(hsb$SEX,
levels = c(1, 2),
labels = c("Male", "Female"))
hsb$RACE = factor(
hsb$RACE,
levels = c(1, 2, 3, 4),
labels = c("Hispanic", "Asian", "Black", "White")
)
hsb$HSP = factor(
hsb$HSP,
levels = c(1, 2, 3),
labels = c("General", "Academic", "Vocational")
)
hsb$SCTYP = factor(hsb$SCTYP,
levels = c(1, 2),
labels = c("Public", "Private"))
# a ordinal:
hsb$SES = ordered(hsb$SES,
levels = c(1, 2, 3),
labels = c("Low", "Medium", "High"))
#hsb
# Gráfica de correlación
library(ggplot2)
base = ggplot(data = hsb, aes(x = WRTG, y = MATH))
base + geom_point(aes(color = SCI))
# Hay aparente relación:
f1 = formula( ~ MATH + WRTG) # Asimétricas, correlacionadas pero ninguna es V.D. o V.I.
# camino parametrico:
pearsonf1 = cor.test(f1, data = hsb)[c('estimate', 'p.value')]
pearsonf1
# camino no parametrico
spearmanf1 = cor.test(f1, data = hsb, method = 'spearman')[c('estimate', 'p.value')]
spearmanf1
# el coeficiente de Pearson 0.6326664 (con p-value= 0). Spearman:0.6415126 (con p-value= 0).
ggpubr
utils::contrib.url(repos, "source")
install.packages("ggpubr")
#install.packages("ggpubr")
library(ggpubr)
ggerrorplot(data = hsb, x = "SEX", y = "MATH")
library(ggplot2)
ggplot(hsb, aes(x = MATH)) +
geom_histogram(aes(y = ..density..), bins = 20, fill = 'green') +
stat_function(
fun = dnorm,
colour = "red",
args = list(
mean = mean(hsb$MATH, na.rm = TRUE),
sd = sd(hsb$MATH, na.rm = TRUE)
)
) +
facet_grid( ~ SEX) +
coord_flip()
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(rio)
organization = 'https://github.com/Estadistica-AnalisisPolitico'
repo = '/DataFiles-estadistica/raw/main/'
file = 'hsb_ok.xlsx'
hsb = import(paste0(organization, repo, file)) # importando 3 datas
#str(hsb)
# FORMATEAMOS:
categoricals = c("SEX", "RACE", "SES", "SCTYP", "HSP", "CAR")
hsb[, categoricals] = lapply(hsb[, categoricals], as.factor)
# nominales
hsb$SEX = factor(hsb$SEX,
levels = c(1, 2),
labels = c("Male", "Female"))
hsb$RACE = factor(
hsb$RACE,
levels = c(1, 2, 3, 4),
labels = c("Hispanic", "Asian", "Black", "White")
)
hsb$HSP = factor(
hsb$HSP,
levels = c(1, 2, 3),
labels = c("General", "Academic", "Vocational")
)
hsb$SCTYP = factor(hsb$SCTYP,
levels = c(1, 2),
labels = c("Public", "Private"))
# a ordinal:
hsb$SES = ordered(hsb$SES,
levels = c(1, 2, 3),
labels = c("Low", "Medium", "High"))
#hsb
# Gráfica de correlación
library(ggplot2)
base = ggplot(data = hsb, aes(x = WRTG, y = MATH))
base + geom_point(aes(color = SCI))
# Hay aparente relación:
f1 = formula( ~ MATH + WRTG) # Asimétricas, correlacionadas pero ninguna es V.D. o V.I.
# camino parametrico:
pearsonf1 = cor.test(f1, data = hsb)[c('estimate', 'p.value')]
pearsonf1
# camino no parametrico
spearmanf1 = cor.test(f1, data = hsb, method = 'spearman')[c('estimate', 'p.value')]
spearmanf1
# el coeficiente de Pearson 0.6326664 (con p-value= 0). Spearman:0.6415126 (con p-value= 0).
f2 = formula( ~ MATH + SCI)
# camino parametrico
pearsonf2 = cor.test(f2, data = hsb)[c('estimate', 'p.value')]
# camino no parametrico
spearmanf2 = cor.test(f2, data = hsb, method = 'spearman')[c('estimate', 'p.value')]
# correlación de SCI con MATH, obteniendo el Pearson (0.6495261,p-value= 0) y el Spearman (0.6551515,p-value= 0).
pearsonf2
spearmanf2
base = ggplot(data = hsb, aes(x = SEX, y = MATH))
base + geom_boxplot(notch = T) +  geom_jitter(color = "black",
size = 0.4,
alpha = 0.9)
#install.packages("ggpubr")
library(ggpubr)
ggerrorplot(data = hsb, x = "SEX", y = "MATH")
library(ggplot2)
ggplot(hsb, aes(x = MATH)) +
geom_histogram(aes(y = ..density..), bins = 20, fill = 'green') +
stat_function(
fun = dnorm,
colour = "red",
args = list(
mean = mean(hsb$MATH, na.rm = TRUE),
sd = sd(hsb$MATH, na.rm = TRUE)
)
) +
facet_grid( ~ SEX) +
coord_flip()
# se sugiere normalidad si los puntos no se alejan de la diagonal.
library(ggpubr)
ggqqplot(data = hsb, x = "MATH") + facet_grid(. ~ SEX)
# install.packages("kableExtra")
library(knitr)
library(magrittr)
library(kableExtra)
h3 = formula(MATH ~ SEX)
# función
shapInfo = function(x) {
y = shapiro.test(x)
c(y$statistic, y$p.value)
}
tablag = aggregate(data = hsb,
h3,
FUN = shapInfo)
# para que se vea mejor:
shapiroTable = tablag[, 1] # columna 1
WandPval = as.data.frame(tablag[, 2]) # columnas 2 y 3
shapiroTable = cbind(shapiroTable, WandPval) # todo junto
names(shapiroTable)[c(1, 3)] = c("SEX", "Pval") # cambia nombre de 1 y 2da columna
kable(shapiroTable) %>%
kable_styling()
wilcoxh3 = wilcox.test(h3, data = hsb)['p.value']
wilcoxh3
base = ggplot(data = hsb, aes(x = WRTG, y = MATH))
base + geom_point(aes(color = SEX))
base + geom_point(aes(size = SCI, color = SEX))
base + geom_point(aes(color = SCI)) + facet_grid( ~ SEX)
paleta <- c("coral1", "cyan")
colors <- paleta[as.numeric(hsb$SEX)]
scatterplot3d(hsb[, c('SCI', 'WRTG', 'MATH')], color = colors)
paleta <- c("coral1", "cyan")
colors <- paleta[as.numeric(hsb$SEX)]
library(scatterplot3d)
scatterplot3d(hsb[, c('SCI', 'WRTG', 'MATH')], color = colors)
modelo1 = formula(MATH ~ WRTG)
modelo2 = formula(MATH ~ WRTG + SCI)
modelo3 = formula(MATH ~ WRTG + SCI + SEX)
summary(lm(modelo1, data = hsb))
#install.packages("stargazer")
library(stargazer)
reg1 = lm(modelo1, data = hsb)
summary(reg1)
stargazer(reg1, type = "text", intercept.bottom = FALSE)
ggplot(hsb, aes(x = WRTG, y = MATH)) +
geom_point() +
geom_smooth(method = lm)
reg2 = lm(modelo2, data = hsb)
summary(reg2)
stargazer(reg2, type = "text", intercept.bottom = FALSE)
library(scatterplot3d)
G  <- scatterplot3d(hsb[, c('SCI', 'WRTG', 'MATH')])
G$plane3d(reg2, draw_polygon = TRUE, draw_lines = FALSE)
tanova = anova(reg1, reg2)
tanova
stargazer(tanova,
type = 'text',
summary = F,
title = "Table de Análisis de Varianza")
reg3 = lm(modelo3, data = hsb)
summary(reg3)
library(scatterplot3d)
colors <- paleta[as.numeric(hsb$SEX)]
G  <- scatterplot3d(hsb[, c('SCI', 'WRTG', 'MATH')], color = colors)
G$plane3d(reg2, draw_polygon = TRUE, draw_lines = FALSE)
library(stargazer)
stargazer(reg1, reg2, reg3, type = "text")
stargazer(reg1,
reg2,
reg3,
type = "text",
title = "Modelos planteadas",
digits = 2,
single.row = F,
no.space = F,
intercept.bottom = FALSE,
dep.var.caption = "Variable dependiente:",
dep.var.labels = "Desempeño en Matemáticas",
covariate.labels = c("Constante",
"Desempeño en Escritura",
"Desempeño en Ciencias",
"SEXO (mujer)"),
keep.stat = c("n", "adj.rsq", "ser"),
df = F,
notes.label = "Notas:")
#install.packages("sjPlot")
library(ggplot2)
library(sjPlot)
plot_models(reg1,
reg2,
reg3,
vline.color = "grey",
m.labels = c("Modelo 1", "Modelo 2", "Modelo 3"))
